import numpy as np
import matplotlib.pyplot as plt

def get_frame_boundaries(w, h, x, y, chi=0):
    # Convert chi to radians for rotation
    chi_rad = np.deg2rad(chi)

    # Calculate the four corners of the unrotated FOV (xmin, ymin, etc.)
    xmin = float(x) - float(w) / 2.0
    xmax = float(x) + float(w) / 2.0
    ymin = float(y) - float(h) / 2.0
    ymax = float(y) + float(h) / 2.0
    
    # Correct for boundary limits
    xmin = 0 if xmin < 0 else xmin
    xmax = 360 if xmax > 360 else xmax
    ymin = -90 if ymin < -90 else ymin
    ymax = 90 if ymax > 90 else ymax
    
    # Define the unrotated corners as (RA, Dec) pairs
    corners = np.array([[xmin, ymin],  # bottom-left
                        [xmin, ymax],  # top-left
                        [xmax, ymax], # top-right
                        [xmax, ymin]]) # bottom-right

    # Translate the FOV center to the origin for rotation
    translated_corners = corners - np.array([x, y])

    # Apply 2D rotation matrix to each corner (rotation around z-axis)
    rotation_matrix = np.array([[np.cos(chi_rad), -np.sin(chi_rad)],
                                [np.sin(chi_rad),  np.cos(chi_rad)]])
    
    rotated_corners = np.dot(translated_corners, rotation_matrix.T)

    # Translate the corners back to their original position
    rotated_corners += np.array([x, y])

    # Ensure RA stays within [0, 360] and Dec stays within [-90, 90]
    rotated_corners[:, 0] = rotated_corners[:, 0] % 360
    rotated_corners[:, 1] = np.clip(rotated_corners[:, 1], -90, 90)

    radius = np.sqrt((w/2)**2 + (h/2)**2)

    # Return both the unrotated and rotated corners
    return corners, rotated_corners, radius

def plot_fov_boundaries(w, h, ra, dec, chi):
    # Get unrotated and rotated corners
    unrotated_corners, rotated_corners, radius = get_frame_boundaries(w, h, ra, dec, chi)
    
    # Add the first corner at the end to close the loop
    unrotated_corners = np.vstack([unrotated_corners, unrotated_corners[0]])
    rotated_corners = np.vstack([rotated_corners, rotated_corners[0]])
    # unrotated_corners[[1, 2, 3]] = unrotated_corners[[2, 3, 1]]
    # rotated_corners[[2, 3]] = rotated_corners[[3, 2]]
    
    # Plotting the unrotated and rotated boundaries
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.plot(unrotated_corners[:, 0], unrotated_corners[:, 1], 'r-', label='Unrotated FOV')
    ax.plot(rotated_corners[:, 0], rotated_corners[:, 1], 'b-', label=f'Rotated FOV by {chi}Â°')

    # Mark the center of the FOV
    ax.scatter([ra], [dec], color='green', marker='o', label='FOV Center')

    # Plot the circumscribing circle
    circle = plt.Circle((ra, dec), radius, color='green', fill=False, linestyle='--', label='Circumscribing Circle')
    ax.add_artist(circle)

    # Add labels and legend
    ax.set_xlabel('RA (degrees)')
    ax.set_ylabel('Dec (degrees)')
    ax.set_title('Field of View Boundaries (Unrotated vs Rotated)')
    ax.legend()

    # Set the aspect ratio to be equal
    ax.set_aspect('equal', 'box')

    # Display the plot
    plt.grid(True)
    plt.show()

# Example usage
w, h = 10, 25  # Width and height of FOV in degrees
ra, dec = 20, 45  # Center of FOV (RA, Dec)
chi = 15  # Rotation angle in degrees

# Plot the boundaries
plot_fov_boundaries(w, h, ra, dec, chi)
